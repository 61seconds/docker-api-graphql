scalar StringAnyMap
scalar StringSet
scalar Date

schema {
  query: Query
}

type Query {
    system: System
    swarm: Swarm
    containers(all: Boolean, limit: Int, size: Boolean, filter: ContainerFilter): [Container]
    images(all: Boolean, digests: Boolean, filter: ImageFilter): [Image]
    searchImagesOnDockerHub(term: String!): [ImageSearchResult]
    volumes(filter: VolumeFilter): VolumeList
    networks(filter: NetworkFilter): [Network]
}

type System {
    version: SystemVersion!
    info: SystemInfo!
}

type SystemVersion {
    apiVersion: String!
    arch: String!
    buildTime: String!
    gitCommit: String!
    goVersion: String!
    kernelVersion: String!
    os: String!
    version: String!
#    experimental: Boolean!
}

type SystemInfo {
    architecture: String
    clusterStore: String
    cgroupDriver: String
    containers: Int
    containersRunning: Int
    containersStopped: Int
    containersPaused: Int
    cpuCfsPeriod: Boolean
    cpuCfsQuota: Boolean
    debug: Boolean
    dockerRootDir: String
    storageDriver: String
#    driverStatus: [[String]]
    executionDriver: String
    experimentalBuild: Boolean
    httpProxy: String
    httpsProxy: String
    id: ID!
    ipv4Forwarding: Boolean
    images: Int
    indexServerAddress: String
    initPath: String
    initSha1: String
    kernelMemory: Boolean
    kernelVersion: String
    labels: [String]
    memTotal: Long
    memoryLimit: Boolean
    cpus: Int
    eventsListener: Int
    fileDescriptors: Int
    goroutines: Int
    name: String
    noProxy: String
    oomKillDisable: Boolean
    operatingSystem: String
    osType: String
    plugins: Plugins
    registryConfig: RegistryConfig
    serverVersion: String
    swapLimit: Boolean
    swarm: SwarmInfo
#    systemStatus: [[String]]
    systemTime: Date
}

type Plugins {
    volumes: [String]
    networks: [String]
}

type RegistryConfig {
    insecureRegistryCidrs: [String]
    indexConfigs: StringAnyMap
}

type SwarmInfo {
    cluster: SwarmCluster
    controlAvailable: Boolean
    error: String
    localNodeState: String
    nodeAddr: String
    nodeId: String
    nodes: Int
    managers: Int
    remoteManagers: [RemoteManager]
}

type SwarmCluster {
    id: ID!
    version: SwarmVersion
    createdAt: Date
    updatedAt: Date
    swarmSpec: SwarmSpec
}

type SwarmVersion {
    index: Long
}

type RemoteManager {
    addr: String
    nodeId: String
}

type TopResults {
    titles: [String]
#    processes: ImmutableList<ImmutableList<String>>
}

type ContainerStats {
    read: Date
    network: NetworkStats
    networks: StringAnyMap
    memoryStats: MemoryStats
#    blockIoStats: BlockIoStats
    cpuStats: CpuStats
    precpuStats: CpuStats
}

type CpuStats {
    cpuUsage: CpuUsage
    systemCpuUsage: Long
    throttlingData: ThrottlingData
}

type ThrottlingData {
    periods: Long
    throttledPeriods: Long
    throttledTime: Long
}

type CpuUsage {
    totalUsage: Long
    percpuUsage: [Long]
    usageInKernelmode: Long
    usageInUsermode: Long
}

type NetworkStats {
    rxBytes: Long
    rxPackets: Long
    rxDropped: Long
    rxErrors: Long
    txBytes: Long
    txPackets: Long
    txDropped: Long
    txErrors: Long
}

#type BlockIoStats {
#
#}

type MemoryStats {
    stats: Stats
    maxUsage: Long
    usage: Long
    failcnt: Long
    limit: Long
}

type Stats {
    activeFile: Long
    totalActiveFile: Long
    inactiveFile: Long
    totalInactiveFile: Long
    cache: Long
    totalCache: Long
    activeAnon: Long
    totalActiveAnon: Long
    inactiveAnon: Long
    totalInactiveAnon: Long
    hierarchicalMemoryLimit: BigInteger
    mappedFile: Long
    totalMappedFile: Long
    pgmajfault: Long
    totalPgmajfault: Long
    pgpgin: Long
    totalPgpgin: Long
    pgpgout: Long
    totalPgpgout: Long
    pgfault: Long
    totalPgfault: Long
    rss: Long
    totalRss: Long
    rssHuge: Long
    totalRssHuge: Long
    unevictable: Long
    totalUnevictable: Long
    totalWriteback: Long
    writeback: Long
}

type Container {
    id: ID!
    names: [String]
    image: String
    imageId: String
    command: String
    created: Long
    state: String
    status: String
    ports: [PortMapping]
    labels: StringAnyMap
    sizeRw: Long
    sizeRootFs: Long
    networkSettings: NetworkSettings
    mounts: [ContainerMount]

    details: ContainerDetails
    processes(ps_args: String): TopResults
    stats: ContainerStats
    logs(follow: Boolean, stdout: Boolean, stderr: Boolean, since: Int, timestamps: Boolean, lines: Int, customParams: StringAnyMap): String
    changes: [ContainerChange]

    portsAsString: String
}

type ContainerChange {
    path: String
    kind: Int
}

type ContainerDetails {
    id: ID!
    created: Date
    path: String
    args: [String]
    config: ContainerConfig
    hostConfig: HostConfig
    state: ContainerState
    image: String
    networkSettings: NetworkSettings
    resolvConfPath: String
    hostnamePath: String
    hostsPath: String
    name: String
    driver: String
    execDriver: String
    processLabel: String
    mountLabel: String
    volumes: StringAnyMap
    volumesRw: StringAnyMap
    appArmorProfile: String
    execIds: [String]
    logPath: String
    restartCount: Long
    mounts: [ContainerMount]
    node: Node
}

type Node {
    id: ID!
    ip: String
    addr: String
    name: String
}

type ContainerMount {
    type: String
    name: String
    source: String
    destination: String
    driver: String
    mode: String
    rw: Boolean
    propagation: String
}

type NetworkSettings {
    ipAddress: String
    ipPrefixLen: Int
    gateway: String
    bridge: String
    portMapping: StringAnyMap
    ports: StringAnyMap
    macAddress: String
    networks: StringAnyMap
    endpointId: String
    sandboxId: String
    sandboxKey: String
    hairpinMode: Boolean
    linkLocalIPv6Address: String
    linkLocalIPv6PrefixLen: Int
    globalIPv6Address: String
    globalIPv6PrefixLen: Int
    ipv6Gateway: String
}

type ContainerState {
    status: String
    running: Boolean
    paused: Boolean
    restarting: Boolean
    pid: Int
    exitCode: Int
    startedAt: Date
    finishedAt: Date
    error: String
    oomKilled: Boolean
    health: Health
}

type Health {
    status: String
    failingStreak: Int
    log: [HealthLog]
}

type HealthLog {
    start: Date
    end: Date
    exitCode: Int
    output: String
}

type HostConfig {
    binds: [String]
    blkioWeight: Int
    blkioWeightDevice: [BlkioWeightDevice]
    blkioDeviceReadBps: [BlkioDeviceRate]
    blkioDeviceWriteBps: [BlkioDeviceRate]
    blkioDeviceReadIOps: [BlkioDeviceRate]
    blkioDeviceWriteIOps: [BlkioDeviceRate]
    containerIdFile: String
    lxcConf: [LxcConfParameter]
    privileged: Boolean
    portBindings: StringAnyMap
    links: [String]
    publishAllPorts: Boolean
    dns: [String]
    dnsOptions: [String]
    dnsSearch: [String]
    extraHosts: [String]
    volumesFrom: [String]
    capAdd: [String]
    capDrop: [String]
    networkMode: String
    securityOpt: [String]
    devices: [Device]
    memory: Long
    memorySwap: Long
    memorySwappiness: Int
    memoryReservation: Long
    nanoCpus: Long
    cpuPeriod: Long
    cpuShares: Long
    cpusetCpus: String
    cpusetMems: String
    cpuQuota: Long
    cgroupParent: String
    restartPolicy: RestartPolicy
    logConfig: LogConfig
    ipcMode: String
    ulimits: [Ulimit]
    pidMode: String
    shmSize: Long
    oomKillDisable: Boolean
    oomScoreAdj: Int
    autoRemove: Boolean
    pidsLimit: Int
    tmpfs: StringAnyMap
    readonlyRootfs: Boolean
    storageOpt: StringAnyMap
}

type Ulimit {
    name: String
    soft: Long
    hard: Long
}

type LogConfig {
    logType: String
    logOptions: StringAnyMap
}

type RestartPolicy {
    name: String
    maxRetryCount: Int
}

type Device {
    pathOnHost: String
    pathInContainer: String
    cgroupPermissions: String
}

type LxcConfParameter {
    key: String
    value: String
}

type BlkioDeviceRate {
    path: String
    rate: Int
}

type BlkioWeightDevice {
    path: String
    weight: Int
}

type ContainerConfig {
    hostname: String
    domainname: String
    user: String
    attachStdin: Boolean
    attachStdout: Boolean
    attachStderr: Boolean
    portSpecs: [String]
    exposedPorts: StringSet
    tty: Boolean
    openStdin: Boolean
    stdinOnce: Boolean
    env: [String]
    cmd: [String]
    image: String
    volumeNames: StringSet
    volumes: StringAnyMap
    workingDir: String
    entrypoint: [String]
    networkDisabled: Boolean
    onBuild: [String]
    labels: StringAnyMap
    macAddress: String
    hostConfig: HostConfig
    stopSignal: String
    healthcheck: Healthcheck
    networkingConfig: NetworkingConfig
}

type NetworkingConfig {
   endpointsConfig: StringAnyMap
}

type Healthcheck {
    test: [String]
    interval: Long
    timeout: Long
    retries: Int
    startPeriod: Long
}

input ContainerFilter {
    ancestor: [String]
    before: [String]
    expose: [String]
    exited: [Int]
    health: [ContainerHealth]
    id: [String]
    isolation: [ContainerIsolation]
    is_task: [Boolean]
    label: [String]
    name: [String]
    network: [String]
    publish: [String]
    since: [String]
    status: [ContainerStatus]
    volume: [String]
}

enum ContainerHealth {
    starting
    healthy
    unhealthy
    none
}

enum ContainerIsolation {
    default
    process
    hyperv
}

enum ContainerStatus {
    created
    restarting
    running
    removing
    paused
    exited
    dead
}

type PortMapping {
    privatePort: Int
    publicPort: Int
    type: String
    ip: String
}

type Image {
    created: String
    id: ID!
    parentId: String
    repoTags: [String]
    repoDigests: [String]
    size: Long
    virtualSize: Long
    labels: StringAnyMap

    details: ImageDetails
    history: [ImageHistory]
}

input ImageFilter {
    before: [String]
    dangling: [Boolean]
    label: [String]
    reference: [String]
    since: [String]
}

type ImageDetails {
    id: ID!
    parent: String
    comment: String
    created: Date
    container: String
    containerConfig: ContainerConfig
    dockerVersion: String
    author: String
    config: ContainerConfig
    architecture: String
    os: String
    size: Long
    virtualSize: String
    rootFs: RootFs
}

type RootFs {
    type: String
    layers: [String]
}

type ImageHistory {
    id: ID!
    created: Long
    createdBy: String
    tags: [String]
    size: Long
    comment: String
}

type ImageSearchResult {
    description: String
    official: Boolean
    automated: Boolean
    name: String
    starCount: Int
}

type VolumeList {
    volumes: [Volume]
    warnings: [String]
}

type Volume {
    name: String
    driver: String
    driverOpts: StringAnyMap
    labels: StringAnyMap
    mountpoint: String
    scope: String
    status: StringAnyMap
}

input VolumeFilter {
    dangling: [Boolean]
    driver: [String]
    label: [String]
    name: [String]
}

type Network {
    name: String
    id: ID!
    scope: String
    driver: String
    ipam: Ipam
    containers: StringAnyMap
    options: StringAnyMap
    internal: Boolean
    enableIPv6: Boolean
    labels: StringAnyMap
    attachable: Boolean
}

type Ipam {
    driver: String
    config: [IpamConfig]
}

type IpamConfig {
    subnet: String
    ipRange: String
    gateway: String
}

input NetworkFilter {
    driver: [String]
    id: [String]
    label: [String]
    name: [String]
    scope: [NetworkScope]
    type: [NetworkType]
}

enum NetworkScope {
    swarm
    global
    local
}

enum NetworkType {
    custom
    builtin
}

type Swarm {
    id: ID!
    version: SwarmVersion
    createdAt: Date
    swarmSpec: SwarmSpec
    joinTokens: JoinTokens

    unlockKey: UnlockKey
    nodes(filter: NodeFilter): [SwarmNode]
}

type SwarmSpec {
    name: String
    labels: StringAnyMap
    orchestration: OrchestrationConfig
    raft: RaftConfig
    dispatcher: DispatcherConfig
    caConfig: CaConfig
    encryptionConfig: EncryptionConfig
    taskDefaults: TaskDefaults
}

type OrchestrationConfig {
    taskHistoryRetentionLimit: Int
}

type RaftConfig {
    snapshotInterval: Int
    keepOldSnapshots: Int
    logEntriesForSlowFollowers: Int
    electionTick: Int
    heartbeatTick: Int
}

type DispatcherConfig {
    heartbeatPeriod: Long
}

type CaConfig {
    nodeCertExpiry: Long
    externalCas: [ExternalCa]
}

type ExternalCa {
    protocol: String
    url: String
    options: StringAnyMap
}

type EncryptionConfig {
    autoLockManagers: Boolean
}

type TaskDefaults {
    logDriver: Driver
}

type Driver {
    name: String
    options: StringAnyMap
}

type JoinTokens {
    worker: String
    manager: String
}

type UnlockKey {
    unlockKey: String
}

type SwarmNode {
    id: String
    version: SwarmVersion
    createdAt: Date
    updatedAt: Date
    spec: NodeSpec
    description: NodeDescription
    status: NodeStatus
    managerStatus: ManagerStatus

    details: NodeInfo
}

type NodeSpec {
    name: String
    labels: StringAnyMap
    role: String
    availability: String
}

type NodeDescription {
    hostname: String
    platform: Platform
    resources: Resources
    engine: EngineConfig
}

type Platform {
    architecture: String
    os: String
}

type Resources {
    nanoCpus: Long
    memoryBytes: Long
}

type EngineConfig {
    engineVersion: String
    labels: StringAnyMap
    plugins: [EnginePlugin]
}

type EnginePlugin {
    type: String
    name: String
}

type NodeStatus {
    state: String
    addr: String
}

type ManagerStatus {
    leader: Boolean
    reachability: String
    addr: String
}

input NodeFilter {
    id: [String]
    label: [String]
    membership: [NodeMembership]
    name: [String]
    role: [NodeRole]
}

enum NodeMembership {
    accepted
    pending
}

enum NodeRole {
    manager
    worker
}

type NodeInfo {
    id: ID!
    version: SwarmVersion
    createdAt: Date
    updatedAt: Date
    spec: NodeSpec
    description: NodeDescription
    status: NodeStatus
    managerStatus: ManagerStatus
}